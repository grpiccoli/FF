#' @rdname plotHist
#' @title Plot histogram
#' @description Plot the histogram of the thinned vs harvested vs total.
#'
#' @param obj A \code{FullSimulation} object generated by the \code{\link[fpfi3]{FullSimulation}} function.
#' @param ids A vector of idg to plot. Is the 'idg' column of the "main" parameter in the list returned by the BatchGrowing function. Default is NULL (first 9 ploted)
#' @param macrostands A vector of names.
#' @param plot if TRUE, the plot will be displayed. Default is TRUE.
#' @param subset A number, indicating the maximum number of plots to display (to avoid saturation). Default value is 25 (5x5 grid).
#' @param points.after An integer, indicating how many years after the thinning to plot (usually to compare). Default is 0 (no plot).
#' @details A maximum of 16 plots are allowed in one single call.
#'
#' @author Álvaro Paredes, \email{alvaro.paredes@fpfi.cl}
#' @seealso \code{\link[fpfi3]{FullSimulation}}
#' @return A plot, where grey is the pre-thinned distribution, blue is the thinned distribution and red is the after-thinning distribution of trees.
#' If \code{points.after != 0}, the distribution will appear in green.
#' @importFrom grDevices rgb
#' @import lattice
#' @export
#' @examples
#' library(fpfi3)
#'
#' # Let's use the data loaded inside this package:
#' initial_conditions  # See ?initial_conditions for a detailed description.
#' taper_coeffs  # See ?taper_coeffs for a detailed description.
#' demo_products  # See ?demo_products for a detailed description.
#'
#' # Running the simulation
#' input_data <- list(df=initial_conditions, params=taper_coeffs, prods=demo_products)
#' sims <- FullSimulation(in_data = input_data,
#'                        age_range = c(15,30), distribution = "normal",
#'                        distribution_thinning = "normal", include_thinning = TRUE,
#'                        species="eucalyptus_grandis", model = "dss", volform = "smalian",
#'                        way = "lmak", region = 'uruguay_solid')
#'
#' plotHist(sims)  # plot all
#' plotHist(sims, macrostands = c("A1", "A2"))
#' plotHist(sims, macrostands = c("A1", "A2"), points.after=1)
#'
plotHist <- function(obj, ids=NULL, macrostands=NULL, plot=TRUE, subset=25, points.after=0){

  # To avoid RMD checks notes:
  supid <- NULL; id <- NULL; thin_type <- NULL; thin_coef <- NULL; distr <- NULL; idg <- NULL; macrostand <- NULL; type <- NULL

  if (class(obj) != "FullSimulation") {
    stop("Input is not a FullSimulation class")
  }
  requireNamespace("lattice")

  if (!is.null(macrostands)) {
    stemp <- merge(obj$growth$main, obj$input$initial_conditions[, c("id", "macrostand")], by="id")
    ids <- unlist(stemp[stemp$macrostand %in% macrostands & stemp$thinaction==1, "idg"])
  }

  if (is.null(ids)) {
    ids <- names(obj$growth$detail)
  }

  lx <- subset  # Max number of plots
  if (length(ids) > lx) {
    warning(paste0("Number of plots is greater than ", lx, " . The last ", length(ids) - lx, " registers were removed."))
  } else {
    lx <- length(ids)
  }
  ids <- as.character(ids[1:lx])  # names(obj$growth$detail)[lx]
  dt <- obj$growth$detail[ids]

  lista <- list()
  subsc <- list(c('full_sim', 'trees'), c('thin_sim', 'trees'), c('standing_trees'))
  for (x in 1:length(subsc)) {
    temp <- lapply(dt, `[[`, subsc[[x]])
    t_trees <- cbind(rep(as.numeric(names(dt)), unlist(lapply(temp, length))), unlist(temp), x)
    colnames(t_trees) <- c("idg", "DBH", "type")
    lista[[x]] <- data.table(t_trees)
  }

  if (points.after > 0) {
    aftT <- obj$growth$main[obj$growth$main$idg %in% (as.numeric(ids) + 1), ]
    for (z in 1:nrow(aftT)) {
      vals <- with(aftT[z, ],
                   SimulateTrees(N, 1, obj$cl$distribution, Dg, Hd, sd, BA, Age,
                                 species=obj$cl$species, region=obj$cl$region))$trees
      lista[[length(lista) + 1]] <- data.table(idg=aftT$idg[z] - points.after, DBH=vals, type=x + points.after)
    }
  }

  trees <- rbindlist(lista)
  trees <- merge(trees, obj$growth$main, by="idg")
  if (is.null(macrostands)) {
    trees[, supid:=paste0(id, "-", thin_type, "-", thin_coef, "-", distr, "-", idg), by=1:nrow(trees)]
  } else {
    trees <- merge(trees, obj$input$initial_conditions[, c("id", "macrostand")], by="id")
    trees[, supid:=paste0(macrostand, "-", thin_type, "-", thin_coef, "-", distr, "-", idg), by=1:nrow(trees)]
  }
  trees[, supid:=factor(supid, levels=unique(supid))]

  rcolors = c("grey80", rgb(0, 0, 1, .5), rgb(1, 0, 0, .5), rgb(0, 1, 0, .5))
  histo.dbh <- histogram( ~DBH|as.factor(supid),#layout=c(3,2),
                          data = trees,
                          type = "count",
                          breaks = seq(min(trees$DBH) - 1, max(trees$DBH) + 1, by=1),
                          ylim = c(0, max(pretty(1 + max(with(trees, table(idg, type, DBH)))))),
                          groups = type,
                          # scales=list(x=list(labels=rep("", 40))),
                          main ="Diameter Distribution Before/After Thinning and Thinned",
                          panel = function(x, ...){
                            panel.superpose(x,...,
                                            panel.groups=panel.histogram,
                                            col=rcolors,
                                            distribute.type = TRUE)
                            panel.abline(v=mean(trees$DBH), lty=2)
                            # panel.text(lab=mode(groups), x=40, y=80)
                            auto.key=list(columns=3, rectangles=FALSE,
                                          col=c("blue", "red", "green", "black", "magenta", "darkred"))})
  if (plot) {
    plot(histo.dbh)
  }
  print(obj$main[obj$main$idg %in% ids, ])
  return(histo.dbh)
}


#' @rdname bbarplot
#' @md
#' @title Bar Plots Modification
#' @description Creates a modified bar plot, using the native \code{\link[graphics]{barplot}} as base.
#'
#' @param df A \code{\link[fpfi3]{FullSimulation}} object or a data.frame, data.table or matrix (The first column must be an identifier field
#' and the other columns are the variables to be pottled (for example log products).
#' @param legend_space The extra right space to allocate the legend. If NULL no extra space will be considerer. Default is NULL.
#' @param legend_offset The x axis position of the legend; valid ranges goes from -1 to 1 (see \code{inset}
#' in \code{\link[graphics]{legend}}.If NULL, no legend will be displayed. Default is 0.4 (at the right).
#' @param text_rotation The text rotation inside every bar (see srt in \code{\link{text}}). If NULL, no text will be displayed.
#' Default is 0 (no rotation).
#' @param macrostands A character vector indicating the macrostands to plot.
#' Only used if \code{df} is a \code{\link[fpfi3]{FullSimulation}} object.
#' Default is to use the first macrostand available.
#' @param operation 'harvest' or 'thinning'. Default is 'harvest'.
#' Only used if \code{df} is a \code{\link[fpfi3]{FullSimulation}} object.
#' @param ages An integer speDefault is max age.
#' Only used if \code{df} is a \code{\link[fpfi3]{FullSimulation}} object.
#' @param type A character indicating what type of plot to display.
#' Only used if \code{df} is a \code{\link[fpfi3]{FullSimulation}} object. Options are:
#' * \code{'logs'}: Number of logs per dbh class and type.
#' * \code{'value'}: value per dbh class, adding all the value of the log type by dbh class.
#' * \code{'rvalue'}: relative value per dbh class, the same at \code{'value'} but in % relative to the total dbh class.
#' * \code{'volume'}: volume per dbh class, adding all the volume of the log type by dbh class.
#' In all these plots, the frequency of the class it's shown in small numbers below the title.
#' Defaul is 'value'.
#' @param ... Aditional parameters passed to \code{\link[graphics]{barplot}} (as xlab, ylab, col, etc).
#'
#' @details Note that if \code{df} is a \code{\link[fpfi3]{FullSimulation}} object, you could generate some predefined
#' plots. Any arguments passed as \code{...} will have priority over any other internal pre-defined value.
#' @author Álvaro Paredes, \email{alvaro.paredes@fpfi.cl}
#' @seealso \code{\link[fpfi3]{DoBucking}}, \code{\link[fpfi3]{FullSimulation}}
#' @importFrom graphics barplot legend par axis text
#' @importFrom grDevices terrain.colors
#' @export
#' @examples
#' library(fpfi3)
#' library(data.table)
#'
#' # We're going to use the package demo data:
#' # initial_conditions, taper_coeffs, demo_products
#' trees <- DoBucking(initial_conditions, taper_coeffs, demo_products,
#'                    id='id', dbh='Dg', ht='Hd',
#'                    hp='hp', hm='hm', model='dss', volform='smalian', buck='lmak',
#'                    output='logs')
#'
#' # As we're using the initial conditions, we're gonna get few logs.
#' treesm <- trees$logs
#' treesm[, volval:=volume*value]
#'
#' tlength <- dcast(treesm, id~product, length, value.var="volval")
#' tvol <- dcast(treesm, id~product, sum, value.var="volume")
#' tval <- dcast(treesm, id~product, sum, value.var="volval")
#'
#' # Number of logs
#' bbarplot(tlength, legend_space=10, legend_offset=.35,
#'          xlab="Tree", ylab="Logs", ylim=c(0, 7),
#'          main="Number of logs by tree")
#'
#' # Volume
#' bbarplot(tvol, legend_space=10, legend_offset=.35,
#'          xlab="Tree", ylab="Volume", ylim=c(0, 1),
#'          main="Volume per tree")
#'
#' # Value
#' bbarplot(tval, legend_space=10, legend_offset=.35,
#'          xlab="Tree", ylab="Value", ylim=c(0, 16),
#'          main="Value by tree")
#'
#' # Relative log value
#' bbarplot(cbind(tval[, 1], tval[, -1] / rowSums(tval[, -1])*100),
#'          legend_space=10, legend_offset=.35,
#'          xlab="Tree", ylab="% of the tree value", ylim=c(0, 100),
#'          main="Value by tree")
#'
bbarplot <- function(df, legend_space=NULL, legend_offset=0.4, text_rotation=0,
                     macrostands=NULL, operation="harvest", ages=NULL, type='value', ...) {

  # To avoid RMD checks notes:
  macrostand <- NULL; Age <- NULL; id <- NULL; volval <- NULL; volume <- NULL; value <- NULL

  # operation = 'harvest'; macrostands=NULL; ages=NULL;legend_space=10
  margs <- list()
  if ('FullSimulation' %in% class(df)) {
    if (!operation %in% c('harvest', 'thinning')) {
      stop(paste0("operation input ", operation, " must be 'harvest' or 'thinning'"))
    }
    if (is.null(macrostands)) {
      macrostands <- df$input$initial_conditions$macrostand[1]
    }
    macrostands <- macrostands[1]
    if (is.null(ages)) {
      ages <- df$simulation[macrostand %in% macrostands, list(age=max(Age))]
      ages <- ages$age
    }
    ages <- ages[1]
    df1 <- df$taper$log_level[[operation]][id %in% df$input$initial_conditions$id[df$input$initial_conditions$macrostand %in% macrostands], ]
    df1 <- merge(df$input$initial_conditions[, c("id", "macrostand")], df1, by="id")
    if (operation=='harvest') {
      df1 <- merge(df1, df$simulation[Age %in% ages & macrostand %in% macrostands, c("idg", "Age")], by="idg")
      # df1[, mid:=paste0(macrostand, "-", dbh, "-", Age)]
    }
    df1[, volval:=volume*value]
    # Separar por tipo, y graficar por 1 macrostand y por 1 edad solamente.
    # df1 <- dcast(df1, mid~product, sum, value.var="volval")
    margs <- list(main=paste0("Macrostand ", macrostands, " at age ", ages),
                  xlab="DBH Class")
    if (type %in% c('value', "rvalue")) {
      df2 <- dcast(df1, dbh~product, sum, value.var="volval")
      margs[['ylab']] <- 'Value'
      if (type == "rvalue") {
        df2 <- cbind(df2[, 1], df2[, .SD/rowSums(.SD)*100, .SDcols=colnames(df2)[-1]])
        margs[['ylab']] <- 'Relative value (%)'
      }
    } else if (type == 'logs') {
      df2 <- dcast(df1, dbh~product, length, value.var="volval")
      margs[['ylab']] <- 'Logs'
    } else if (type == 'volume') {
      df2 <- dcast(df1, dbh~product, sum, value.var="volume")
      margs[['ylab']] <- 'Volume'
    }

  } else {
    df2 <- data.table(df)
  }

  opar <- par()$mar
  params <- list(...)
  if (!is.null(legend_space)){
    par(mar=c(5.1, 4.1, 4.1 + 1, legend_space))
  }
  axix <- unlist(df2[, 1])
  dat <- t(df2[, -1])

  if ('col' %in% names(params)) {
    colorx <- params$col
  } else {
    colorx <- terrain.colors(nrow(dat))
  }
  margs[['col']] <- colorx
  margs[['height']] <- dat
  margs <- c(params, margs)  # prioridad a los parametros que ingresa el usuario
  margs <- margs[!duplicated(names(margs))]
  bpp <- do.call(barplot, margs)
  axis(1, bpp, labels=axix)
  if ('FullSimulation' %in% class(df)) {
    axis(3, bpp, labels=unique(df1[, c('dbh', 'freq')])$freq, cex.axis=0.5, tick=F, lwd=0)
  }

  lab <- round(dat)
  if (all(lab == 0)) {
    text_rotation <- NULL
  }
  xs <- rep(bpp, each=nrow(dat))
  ys <- c(apply(dat, 2, function(x) diff(c(0, cumsum(x))) / 2 + c(0, cumsum(x)[-length(x)])))
  fil <- which(lab != 0)

  if (!is.null(text_rotation)) {
    text(x=xs[fil], y=ys[fil], labels=lab[fil], srt=text_rotation, cex=.8)
  }

  if (!is.null(legend_offset)){
    legend("right", legend=colnames(df2)[-1], fill=colorx, bg="grey90", xpd=T, inset=c(legend_offset * -1, 0))
  }

  par(mar=opar)
  return(invisible(bpp))
}
# cc = append(aa, bb)
# cc[!duplicated(names(cc))]
